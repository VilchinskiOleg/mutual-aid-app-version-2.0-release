package com.example.testcontainertests;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import com.example.testcontainertests.entity.MemberItem;
import com.example.testcontainertests.repo.MemberItemRepo;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

/**
 * In this test we initial DB only by SQL script during running docker container.
 * For that we use method withInitScript('path/to/initFile.sql').
 *
 * But if we use such scenario, we can't use JPA auto-creation for tables, because docker container will run before.
 */

@ExtendWith({SpringExtension.class})
@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)

@Testcontainers
@DirtiesContext

@Disabled // only because they are global test end we can skip them during build project.
class MemberItemContainerTestInitDbSqlScript {

  @Container
  public static PostgreSQLContainer<?> postgresDB = new PostgreSQLContainer<>
      ("postgres:13.2")
      .withDatabaseName("testDB")
      .withUsername("postgres")
      .withPassword("postgres")
      .withInitScript("data/ddl_during_running_docker_container.sql");

  @Autowired
  public MemberItemRepo repo;

  @Test
  void saveAndReadEntity() {

    // read and check item generated by script:
    var firstSelect = repo.findById(1L);
    assertTrue(firstSelect.isPresent());
    var firstMember = firstSelect.get();
    assertEquals("first_name_test_1", firstMember.getFirstName());

    // create and check saved item:
    var secondMember = new MemberItem();
    secondMember.setId(2L);
    secondMember.setFirstName("first_name_test_2");
    secondMember.setLastName("last_name_test_2");

    repo.save(secondMember);

    var secondSelect = repo.findById(2L);
    assertTrue(secondSelect.isPresent());
    var secondMemberAfterSaving = secondSelect.get();
    assertEquals(secondMember.getFirstName(), secondMemberAfterSaving.getFirstName());
  }


  @DynamicPropertySource
  public static void properties(DynamicPropertyRegistry registry) {
    registry.add("spring.datasource.url",postgresDB::getJdbcUrl);
    registry.add("spring.datasource.username", postgresDB::getUsername);
    registry.add("spring.datasource.password", postgresDB::getPassword);
    registry.add("spring.jpa.hibernate.ddl-auto", () -> "none");
    registry.add("spring.jpa.show-sql", () -> "true");
  }
}